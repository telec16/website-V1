<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>

		<title>Filters</title>

		<style>
			input[type=text] {
				width:3em;
			}
			input[type=number] {
				width:3em;
			}

			table.data {
				border-collapse: collapse;
				width: 240px;
			}
			table.data tr {
				height:32px;
				border: none;
			}
			table.data td{
				text-align:center;
			}

			table.list {
				border-collapse: collapse;
				border-style: solid;
				width: 600px;
				margin: 2px;
				text-align: left;
			}
			table.list th{
				border-style: outset;
				border-width: 2px;
			}
			table.list thead th{
				text-align:center;
			}
			table.list td{
				border-style: groove;
				border-width: 1px;
				padding-left: 5px;
				padding-right: 5px;
			}
			table.list td.side-text {
				writing-mode:  sideways-lr;
				padding-left: 1em;
			}
		</style>

		<link rel="stylesheet" href="/styleADL.css" />
		<script type='text/javascript' src='https://unpkg.com/mathjs@7.1.0/dist/math.min.js'></script>
		<script type='text/javascript' src='../utils.js'></script>
		<script type='text/javascript'>
			handler=null;
			function timer(type){
				clearTimeout(handler);
				handler = setTimeout(change, 500, type);
			}

			var acc = 3;

			function change(type){
				var H_div = document.getElementById("H");
				var R1_input = document.getElementById("R1");
				var R2_input = document.getElementById("R2");
				var C1_input = document.getElementById("C1");
				var C2_input = document.getElementById("C2");
				var Rf_input = document.getElementById("Rf");
				var K_input  = document.getElementById("K");
				var F0_input = document.getElementById("F0");
				var Q_input  = document.getElementById("Q");
				var serie_input = document.getElementById("serie");

				var lockR  = document.getElementById("lockR" ).checked;
				var lockRf = document.getElementById("lockRf").checked;
				var lockC  = document.getElementById("lockC" ).checked;

				var ctx = document.getElementById("cnv").getContext("2d");

				//Change picture
				var topo = document.getElementById("topology").value;
				document.getElementById("circuit").src = topo+".png";

				//Change configuration
				if(type == "config"){

					switch(topo){
						case "SKlp":
							Rf_input.disabled = true;
							document.getElementById("lockRf").disabled = true;
							if(!lockR && !lockC)
								H_div.innerHTML = "K/(1+(C2(R1+R2)+R1C1(1-K)).p+R1R2C1C2.p²)";
							if(lockR && !lockC)
								H_div.innerHTML = "K/(1+R(2.C2+C1(1-K)).p+C1C2(R.p)²)";
							if(!lockR && lockC)
								H_div.innerHTML = "K/(1+C(R2+R1(2-K)).p+R1R2(C.p)²)";
							if(lockR && lockC)
								H_div.innerHTML = "K/(1+RC(3-K).p+(RC.p)²)";
						break;
						case "SKhp":
							Rf_input.disabled = true;
							document.getElementById("lockRf").disabled = true;
							if(!lockR && !lockC)
								H_div.innerHTML = "K.p²/(1/(R1R2C1C2)+(R1(C1+C2)+R2C2(1-K))/(R1R2C1C2).p+p²)";
							if(lockR && !lockC)
								H_div.innerHTML = "K.p²/(1/(R²C1C2)+(C1+C2(2-K))/(RC1C2).p/(RC1C2)+p²)";
							if(!lockR && lockC)
								H_div.innerHTML = "K.p²/(1/(R1R2C²)+(2.R1+R2(1-K))/(R1R2C).p+p²)";
							if(lockR && lockC)
								H_div.innerHTML = "K.p²/(1/(RC)²+(3-K)/(RC).p+p²)";
						break;
						case "SKbp":
							Rf_input.disabled = false;
							document.getElementById("lockRf").disabled = false;
							if(!lockR && !lockC)
								H_div.innerHTML = "K/(R1C1).p/((R1+Rf)/(R1R2C1C2Rf)+(Rf(R1(C1+C2)+R2C2)+R1R2C2(1-K))/(R1R2C1C2Rf).p+p²)";
							if(lockR && !lockC && !lockRf)
								H_div.innerHTML = "K/(RC1).p/((R+Rf)/(R²C1C2Rf)+(Rf(C1+2.C2)+RC2(1-K))/(RC1C2Rf).p+p²)";
							if(lockR && !lockC && lockRf)
								H_div.innerHTML = "K/(RC1).p/(2/(R²C1C2)+(C1+C2(3-K))/(RC1C2).p+p²)";
							if(!lockR && lockC)
								H_div.innerHTML = "K/(R1C).p/((R1+Rf)/(R1R2C²Rf)+(Rf(2.R1+R2)+R1R2(1-K))/(R1R2CRf).p+p²)";
							if(lockR && lockC && !lockRf)
								H_div.innerHTML = "K/(RC).p/((R+Rf)/(R²C²Rf)+(3.Rf+R(1-K))/(RCRf).p+p²)";
							if(lockR && lockC && lockRf)
								H_div.innerHTML = "K/(RC).p/(2/(RC)²+(4-K)/(RC).p+p²)";
						break;
					}

					if(!lockR) {
						lockRf = document.getElementById("lockRf").checked = false;
						document.getElementById("lockRf").disabled = true;
					}
					if(lockRf)
						Rf_input.disabled = true;

					R2_input.disabled = lockR;
					C2_input.disabled = lockC;
				}

				//Get fields values
				var R1 = Math.abs(floatOf(R1_input, 10 )) * 1e3 ;
				var R2 = Math.abs(floatOf(R2_input, 10 )) * 1e3 ;
				var C1 = Math.abs(floatOf(C1_input, 4.7)) * 1e-9;
				var C2 = Math.abs(floatOf(C2_input, 4.7)) * 1e-9;
				var Rf = Math.abs(floatOf(Rf_input, 6.8)) * 1e3 ;
				var K  = Math.abs(floatOf(K_input , 2.8)) * 1e0 ;
				var F0 = Math.abs(floatOf(F0_input, 10 )) * 1e3 ;
				var Q  = floatOf(Q_input , 2)* 1e0 ;
				var w0 = 2*Math.PI*F0;

				//Match the values
				if(lockR)  R2 = R1;
				if(lockRf) Rf = R1;
				if(lockC)  C2 = C1;

				//Compute components
				if(type == "spec"){
					switch(topo){
						case "SKlp":
							if(!lockR)
								R1 = 1/(w0**2) * 1/(R2*C1*C2);
							else
								R1 = R2 = 1/(w0 * Math.sqrt(C1*C2));
							//R2 = 1/(w0**2) * 1/(R1*C1*C2);
							//C1 = 1/(w0**2) * 1/(R1*R2*C1);
							//C2 = 1/(w0**2) * 1/(R1*R2*C2);
							K = 1 - ( (1/(Q*w0) - C2*(R1+R2)) / (R1*C1) );
						break;
						case "SKhp":
							if(!lockR)
								R1 = 1/(w0**2) * 1/(R2*C1*C2);
							else
								R1 = R2 = 1/(w0 * Math.sqrt(C1*C2));
							K = 1 - ( (1/(Q*w0) - R1*(C1+C2)) / (R2*C2) );
						break;
						case "SKbp":
							if(!lockR)
								R1 = Rf/((w0**2) * (R2*C1*C2*Rf) - 1);
							else if(!lockRf)
								R1 = R2 = (1 + Math.sqrt(1+4*C1*C2*(Rf*w0)**2)) / (2*C1*C2*Rf*w0**2);
							else
								R1 = R2 = Rf = 1/(w0 * Math.sqrt(C1*C2/2));
							K = 1 - ( (1/(Q*w0/(R1+Rf)) - Rf*(R1*(C1+C2) + R2*C2)) / (R1*R2*C2) );
						break;
					}
				}

				//Get closest resistance serie
				if(type == "serie"){
					var s = floatOf(serie_input, 12);
					var serie = getResistorSerie(s);

					R1 = closestInList(serie, R1);
					R2 = closestInList(serie, R2);
					Rf = closestInList(serie, Rf);
				}

				//Compute spec
				if(type == "comp" || type == "config"){
					switch(topo){
						case "SKlp":
							w0 = 1/Math.sqrt(R1*R2*C1*C2);
							Q = 1/w0 * 1/(C2*(R1+R2) + R1*C1*(1-K));
						break;
						case "SKhp":
							w0 = 1/Math.sqrt(R1*R2*C1*C2);
							Q = 1/w0 * 1/(R1*(C1+C2) + R2*C2*(1-K));
						break;
						case "SKbp":
							w0 = Math.sqrt((R1+Rf)/(R1*R2*C1*C2*Rf));
							Q = (R1+Rf)/w0 * 1/(Rf*(R1*(C1+C2) + R2*C2) + R1*R2*C2*(1-K));
						break;
					}
				}

				//Create function
				switch(topo){
					case "SKlp":
						fct = function(p) { return math.complex(K).div( p.div(w0).pow(2). add(p.div(Q*w0)). add(1) );} //K/(1 + p/(Q*w0) + (p/w0)**2)
					break;
					case "SKhp":
						fct = function(p) { return p.pow(2).mul(K).div( p.pow(2). add(p.mul(w0/Q)). add(w0**2) );} //K*p**2/(p**2 + p*w0/Q + w0**2)
					break;
					case "SKbp":
						fct = function(p) { return p.mul(K/(R1*C1)).div( p.pow(2). add(p.mul(w0/Q)). add(w0**2) );} //K*p/R1C1/(p**2 + p*w0/Q + w0**2)
					break;
				}

				//Set fields (1/Infinity => NaN => 0)
				F0 = w0/(2*Math.PI);
				setValue(R1_input, (R1||0)* 1e-3, acc);
				setValue(R2_input, (R2||0)* 1e-3, acc);
				setValue(C1_input, (C1||0)* 1e9 , acc);
				setValue(C2_input, (C2||0)* 1e9 , acc);
				setValue(Rf_input, (Rf||0)* 1e-3, acc);
				setValue(K_input , (K ||0)* 1e0 , acc);
				setValue(F0_input, (F0||0)* 1e-3, acc);
				setValue(Q_input , (Q ||0)* 1e0 , acc);

				drawFct(ctx, fct, w0, 300, 230);
			}

		function drawFct(ctx, fct, w0, xSize, ySize){
			var p, gain;
			var Ca,Cg;
			var gmax, gmin;
			var fmax, fmin;
			fmin = 2*Math.PI*10; //10Hz
			fmax = (w0<200e3) ? 200e3:(w0+50e3); //~20kHz

			//Auto-set range
			for(Ca=0; Ca<xSize; Ca++){
				p = map(Ca, 0, xSize-1, Math.log10(fmin), Math.log10(fmax));
				p = math.complex('i').mul(Math.pow(10, p));
				gain = 20*Math.log10(fct(p).abs());

				//Setup min and max
				if(Ca==0){
					gmax=gain;
					gmin=gain;
				}
				else{
					gmax = Math.max(gmax, gain);
					gmin = Math.min(gmin, gain);
				}
			}
			gmax = Math.max(gmax, 20);
			gmin = Math.min(gmin, -80);

			//Actual drawing
				//Zero lines
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, xSize, ySize);
			ctx.fillStyle = "darkred";
			ctx.fillRect(0, ySize-map(0, gmin, gmax, 0, ySize-1)-1, xSize, 1);
			ctx.fillStyle = "darkblue";
			ctx.fillRect(0, ySize/2, xSize, 1);
				//Semi-Log scale
			for(Ca=0; Ca<xSize; Ca++){
				p = map(Ca, 0, xSize-1, Math.log10(fmin), Math.log10(fmax));
				p = math.complex('i').mul(Math.pow(10, p));
				H = fct(p);

				gain  = 20*Math.log10(H.abs());
				phase = Math.atan(H.im/H.re);

				Cg = map(gain, gmin, gmax, 1, ySize-1);
				Cp = map(phase, -Math.PI/2, Math.PI/2, 1, ySize-1);

				ctx.fillStyle = "red";
				ctx.fillRect(Ca, ySize-Cg, 1, -1);
				ctx.fillStyle = "blue";
				ctx.fillRect(Ca, ySize-Cp, 1, -1);
			}
				//Min/Max
			ctx.fillStyle = "darkred";
			ctx.fillText(gmax.toPrecision(2), 5, 15);
			ctx.fillText(gmin.toPrecision(2), 5, ySize-5);
			ctx.fillStyle = "darkblue";
			ctx.fillText("π/2", xSize-25, 15);
			ctx.fillText("-π/2", xSize-25, ySize-5);
		}

		function computeQ(){
				var tr_div = document.getElementById("resonances");
				var order_input = document.getElementById("order");
				var ripple_input = document.getElementById("ripple");

				var fun = document.getElementById("function").value;
				var order = Math.abs(floatOf(order_input, 2));
				var ripple = Math.abs(floatOf(ripple_input, 0));
				order = Math.max(2, order);

				//Clean up
				for(var td of [...tr_div.getElementsByTagName("td")]){
					tr_div.removeChild(td);
				}

				//Fill up
				for(var o=1; o<=order/2; o++){
					var Q = NaN;

					switch(fun){
						case "bessel":
							ripple_input.disabled = true;
							if(order == 2) Q = 1/(Math.sqrt(3));
						break;
						case "butterworth":
							ripple_input.disabled = true;
							var phi = Math.PI/(2*order) * (order + 2*o - 1);
							Q = 1/(-2*Math.cos(phi));
						break;
						case "chebychev":
							ripple_input.disabled = false;
							var Rdb = 10*Math.log10(ripple**2 + 1);
							var Q2 = {0.01: 0.7247, 0.1: 0.7673, 0.25: 0.8093, 0.5: 0.8638, 1: 0.9564, 3: 1.305};
							var key = closestKeyInList(Q2, Rdb);
							if(order == 2) Q = Q2[key];
						break;
					}

					var td = document.createElement("td");
					setFloat(td, Q, acc);
					tr_div.appendChild(td);
				}

				setValue(order_input, order||0, 0);
				setValue(ripple_input, ripple||0, 3);
		}

		</script>
	</head>

	<body onload="change('config'); computeQ();">
		<H1>Warning: these infos can be total garbage ¯\_(ツ)_/¯</H1>
		<div>
			<p>
			When designing a filter, you have two mains things to consider: what function do you need, and how you will implement it. Here are the most commons choices:
			</p>

			<table class="list">
				<thead>
					<tr><th colspan="4">Functions</th></tr>
				</thead>
				<tbody>
					<tr><th>Family</th><th>Name</th><th>Description</th><th>Use</th></tr>
					<tr><td rowspan="5" class="side-text">Polynomial</td><td>1st order</td><td>The basic RC filter</td><td>Useful for debouncing and smoothing signals</td></tr>
					<tr><td>2nd order</td><td>The most common filter</td><td>Generic filter, see variants below</td></tr>
					<tr><td>Butterworth</td><td>Quite selective filter, really good magnitude response (sharp and straight)</td><td>Low distortion and selective application, but take care of the phase!</td></tr>
					<tr><td>Bessel</td><td>Not really selective, smooth phase transition</td><td>Really good in audio path</td></tr>
					<tr><td>Chebychev</td><td>Really selective, but ripple in the pass band (see Chebychev type 2 for a flat response)</td><td>Not good for audio, but can be used for signal processing.</td></tr>
					<tr><td rowspan="1" class="side-text">Elliptic</td><td>Cauer</td><td>More selective than Chebychev, but the attenuation is limited</td><td>?</td></tr>
				</tbody>
			</table>

			<table class="list">
				<thead>
					<tr><th colspan="3">Topologies</th></tr>
				</thead>
				<tbody>
					<tr><th>Name</th><th>Description</th><th>Use</th></tr>
					<tr><td>RC</td><td>The basic RC filter</td><td>Useful for debouncing and smoothing signals</td></tr>
					<tr><td>LC</td><td>Simple 2nd order filter, with infinite resonance (but you need an inductor)</td><td>Mostly use in power application, as it has no loss (in theory)</td></tr>
					<tr><td>Sallen-Key</td><td>The most common 2nd order topology</td><td>Can implement any 2nd order function, and it's quite controllable: the resonance depend of the gain, and the cutoff frequency of two resistors</td></tr>
					<tr><td>Rausch (MFB)</td><td>No real benefits compared to the Sallen-Key topology, less component, but harder to tune</td><td>Can implement any 2nd order function</td></tr>
					<tr><td>Universal cell</td><td>Really easy to use topology, but need a bit more components</td><td>Quickly design filter, funny to fiddle with, useful when you need different types of I/O</td></tr>
				</tbody>
			</table>
		</div>

		<div>
			<p>
			Select a function to get the corresponding resonance (not complete, <a href="https://www.analog.com/media/en/training-seminars/design-handbooks/Basic-Linear-Design/Chapter8.pdf">go here (p.46)</a>, for more info):
			</p>
			<table>
				<tr><td>Function</td><td>Order</td><td>Ripple</td></tr>
				<tr id="resonances">
					<th><select id="function" onchange="computeQ();">
								<option value="bessel">Bessel</option>
								<option value="butterworth">Butterworth</option>
								<option value="chebychev">Chebychev</option>
							</select></th>
					<th><input type="number" id="order" min="2" step="1" value="2"  onchange="computeQ();"/></th>
					<th><input type="number" id="ripple" min="0" step="0.01" value="1"  onchange="computeQ();"/></th>
				</tr>
			</table>
		</div>

		<div>
			<p>
			Try it out!
			</p>
			<div style="display:inline-block;">
			<table class="data">
				<tr><td colspan="5">
				<select id="topology" onchange="change('config');">
					<option value="SKlp">Sallen-key, low-pass</option>
					<option value="SKhp">Sallen-key, high-pass</option>
					<option value="SKbp">Sallen-key, band-pass</option>
				</select>
				</td></tr>

				<tr style="height: 64px;"><td>H(p)=</td><td colspan="4" id="H"></td></tr>

				<tr style="border-top-style: double;"></td><td>R1</td><td>R2</td><td>C1</td><td>C2</td><td>Rf</td></tr>
				<tr style="height:16px;">
						<td colspan="2"><input type="checkbox" id="lockR"  onchange="change('config');"/></td>
						<td colspan="2"><input type="checkbox" id="lockC"  onchange="change('config');"/></td>
						<td colspan="1"><input type="checkbox" id="lockRf" onchange="change('config');"/></td></tr>
				<tr><td><input type="text" id="R1" onkeyup="timer('comp');"/></td>
						<td><input type="text" id="R2" onkeyup="timer('comp');"/></td>
						<td><input type="text" id="C1" onkeyup="timer('comp');"/></td>
						<td><input type="text" id="C2" onkeyup="timer('comp');"/></td>
						<td><input type="text" id="Rf" onkeyup="timer('comp');"/></td></tr>

				<tr style="border-top-style: double;"><td colspan="3">K=1+Rb/Ra=</td><td colspan="2"><input type="text" id="K" onkeyup="timer('comp');"/></td></tr>

				<tr style="border-top-style: double;"><td colspan="2">F0</td><td></td><td colspan="2">Q</td></tr>
				<tr><td colspan="2"><input type="text" id="F0" onkeyup="timer('spec');"/></td><td></td>
				    <td colspan="2"><input type="text" id="Q" onkeyup="timer('spec');"/></td></tr>

				<tr style="border-top-style: double;"><td colspan="5">
					Get closest <select id="serie" onchange="change('serie');">
						<option value="6">E6</option>
						<option value="12" selected>E12</option>
						<option value="24">E24</option>
						<option value="48">E48</option>
						<option value="96">E96</option>
						<option value="192">E192</option>
					</select> serie <input type="button" value="update" onclick="change('serie');" />
				</td></tr>
			</table>
			</div><div style="display:inline-block;">
			<img src="SKlp.png" id="circuit" width="460" height="230" alt="OpAmp circuit"/>
			</div><div style="display:inline-block;">
			<canvas id="cnv" width="300" height="230" alt="Gain vs frequency"/>
			</div>
		</div>
		(Resistors in kΩ, Capacitors in nF, Frequencies in kHz)
	</body>
</html>
